function [q_out, positions_out, ornt_out] = positionTrajectory2(positions,sr,vMax,cfg,orientations,plt)
% debug: positionTrajectory2(positions,100,0.1,'lu',orientations,1)
nPts = size(positions,1);

% Run IK for all points.

% Get all q values for all points and run FK to verify.
q = zeros(nPts,6);
FKpoints = zeros(nPts,3);

for i=1:nPts
    q(i,:) = inverseKinematics(positions(i,:),orientations(i,:),[],cfg);
    FKpoints(i,:) = forwardKinematics(q(i,:));
end

% Calculating movement absTime based on a vMax. This is a vMax in XYZ/task space!
% We could also pass a absTimestamp for each point.

% Calculate distances between points.
distances = abs(diff(positions));
distances = diag(sqrt(distances*distances.'));

% We create a absTime vector determining how long each path to a point
% should take. e.g. A-B takes 1 second and B-C takes 0.9 seconds.
dTime = distances/vMax;

% Create absTimestamp vector with absolute absTimes.
absTime = [0 cumsum(dTime,1).'];
%absTime = [0 cumsum((2*ones(nPts-1,1))).'];  % Dummy vector.

% Joint acceleration is set to zero at all points, but 
% could be passed as an argument to smoothstep(). We would have to
% find the right velocity and acceleration values for each point though.
acc = 0;

% Joint velocities
% velocities = zeros(nPts,1);

% We assume accelerate to full speed between point 0...1. This
% yields a smoother spline. This should be calculated and passed to
% the interpolator for best results. Same goes for acceleration.
velocities = [zeros(1,6) ;
             vMax*ones(nPts-2,6)
             zeros(1,6)];
         

%velocities = zeros(nPts, 6); % start and end point velocity is zero.

% Calculate how many steps the algorithm wil calculate and declare
% memory. This is not exact, since there are some further ceil()
% calls.
amountOfSteps = ceil(absTime(end)*sr);
qOut = zeros(amountOfSteps,6); % We only save the angles.



% For all six angles, interpolate between current and next taking point
% specific constants into account. '1' turns on plot function, but
% for each interpolation call...

for j = 1:nPts-1
    
    
    
    % Run smoothstep() over each pair of q. (quintic spline
    % interpolation)
    for h = 1:6
        
        
        [qTemp, ~,~,~] = smoothstep(absTime(j),absTime(j+1),...
            q(j,h),q(j+1,h),...
            velocities(j,h),velocities(j+1,h),...
            acc,acc,sr,0);
        
       
        % Create range to paste output. The first range voor pts 1 to 2 starts at 1,
        % subsequent ranges start at the last value + 1.
        if j == 1
            range = 1:size(qTemp,1);  % Transpose for readability
        elseif h == 1  % For every new j. It did it for every new h... 
            range = range(end)+1:range(end)+size(qTemp,1);
        end
        
        qOut(range,h) = qTemp;
    end
end

q_out = qOut;


% Run FK for each set of q found.
FKpointsEase = size(qOut,1);
ornt_out = size(qOut,1);

for g = 1:size(qOut,1)
    [FKpointsEase(g,:), ~, ornt_out(g,:)] = forwardKinematics(qOut(g,:));
end

positions_out = FKpointsEase;






if(plt)
    
    %     Plot q
    figure
    plot(absTime,q,'b-.');
    
    %     Interpolated q
    hold on
    absTimeVec = linspace(absTime(1),absTime(end),size(qOut,1));
    plot(absTimeVec,qOut);
    legend('q1','q2','q3','q4','q5','q6','q1','q2','q3','q4','q5','q6','Location','best');
    
    
    %     Plot points and also plot the FK points
    figure
    plot3(positions(:,1),positions(:,2),positions(:,3),'r-o','LineWidth',1);
    hold on
    plot3(FKpoints(:,1),FKpoints(:,2),FKpoints(:,3),'b-.o','LineWidth',1);
    
    
    %     Now plot the path generated by interpolating q.
    plot3(FKpointsEase(:,1),FKpointsEase(:,2),FKpointsEase(:,3),'b','LineWidth',2);
    box on
    shg
    axis equal
    camproj('perspective')
    legend('Points entered into trajectory','FK points trajectory','Interpolated q','Location','Best');
    
end

% Function end
end
