function [q_out, points_out, ornt_out] = positionTrajectory2(positions,sr,vMax,cfg,orientations,plt)

nPts = size(positions,1);

% Run IK for all points with a dummy orientation vector.
DH = getDH();

% Get all q values for all points and run FK to verify.
q = zeros(nPts,6);
FKpoints = zeros(nPts,3);
for i=1:nPts
    q(i,:) = inverseKinematics(positions(i,:),orientations(i,:),DH,cfg);
    FKpoints(i,:) = forwardKinematics(q(i,:));
end

% Acceleration at endpoint is set to 0
acc = 0;

% A row of dummy velocites for each q in JOINT SPACE. Starts and ends on
% zero
% velocities = [zeros(1,nPts) ;
%              rand(nPts-2,nPts)
%              zeros(1,nPts)];
velocities = zeros(nPts,1);

% Calculate distances between points
distances = abs(diff(positions));
distances = diag(sqrt(distances*distances.'));

% We create a time vector determining how long each path to a point
% should take. e.g. A-B takes 1 second and B-C takes 0.9 seconds.
time = zeros(1,size(distances,1)+1);
time(2:end) = distances/vMax;

% Calculate how many steps the algorithm wil calculate and declare
% memory.
amountOfSteps = ceil(time(end)-time(1))*sr;
qOut = zeros(amountOfSteps,6); % We only save the angles.

% For all six angles, interpolate between current and next taking point
% specific constants into account. '1' turns on plot function, but
% for each interpolation call...
for j = 1:nPts-1
    for h = 1:6
        
        % Run smoothstep over each pair of q.
        [qTemp, ~,~,~] = smoothstep(time(j),time(j+1),...
            q(j,h),q(j+1,h),...
            velocities(j),velocities(j+1),...
            acc,acc,sr,0);
        
        % Het gaat bad als de lengte van het volgende stuk van het
        % pad korter is dan de vorige. Dan is de range leeg. Dit
        % komt omdat de tijdsvector nu de tijd is tussen 2 punten en
        % niet de tijd van het punt zelf. Die wil je namelijk niet
        % meegeven als gebruiker maar juist velocity. De tijd reken
        % je uit op basis van de afstand van de punten en de
        % velocity die je meegeeft aan je EEF. Tot slot zou er nog
        % gekeken kunnen worden naar het verzadigen van de joint
        % velocity. Dan moet wel de hoeveelheid samples die nodig
        % zijn uitgerekt worden, maar dat is te ingewikkeld (en/of 
        % langzaam) en raad ik af. Peace.
        if j == 1
            range = 1:ceil(time(j+1)*sr);
        else
            range = ceil(time(j)*sr)+1:ceil(time(j+1)*sr);
        end
        
        qOut(range,h) = qTemp;
    end
end

q_out = qOut;

% Run FK for each set of q found.
FKpointsEase = zeros(amountOfSteps,3);
ornt_out = zeros(amountOfSteps,3);
for g = 1:amountOfSteps
    [FKpointsEase(g,:), ~, ornt_out(g,:)] = forwardKinematics(qOut(g,:));
end

points_out = FKpointsEase;

if(plt)
    
    % Plot q
    figure
    plot(time,q,'b-.')
    
    % Interpolated q
    hold on
    timeVec = linspace(time(1),time(end),length(qOut));
    plot(timeVec,qOut);
    legend('q1','q2','q3','q4','q5','q6','q1','q2','q3','q4','q5','q6','Location','best');
    
    
    % Plot points and also plot the FK points
    figure
    plot3(positions(:,1),positions(:,2),positions(:,3),'r-o','LineWidth',1);
    hold on
    plot3(FKpoints(:,1),FKpoints(:,2),FKpoints(:,3),'b-.o','LineWidth',1);
    
    
    % Now plot the path generated by interpolating q.
    plot3(FKpointsEase(:,1),FKpointsEase(:,2),FKpointsEase(:,3),'b','LineWidth',2);
    box on
    shg
    axis equal
    camproj('perspective')
    legend('Points entered into trajectory','FK points trajectory','Interpolated q','Location','Best');
    
end
end
