close all;

% Load points
%load('fixed_8.mat');
load('fixed_8_original.mat');
nPts = size(positions,1);

%%%

% Run IK for all points with a dummy orientation vector.
orientation = [1 0 0];
DH = getDH();
config = 'lun';

% Get all q values for all points and run FK to verify.
q = zeros(nPts,6);
FKpoints = zeros(nPts,3);
for i=1:nPts
    q(i,:) = inverseKinematics(positions(i,:),orientation,DH,config);
    FKpoints(i,:) = forwardKinematics(q(i,:));
end

%%% Stuff needed for trajectory generation.
% Sample rate and acceleration constraints for each point. Dummy
% values.
sr = 50;
acc = 0;

% A row of dummy velocites for each q in JOINT SPACE. Starts and ends on
% zero
% velocities = [zeros(1,nPts) ;
%              rand(nPts-2,nPts)
%              zeros(1,nPts)];
velocities = zeros(nPts,1);

% A time vector containing the timestamp of each point. Make sure it
% has the right # of entries.

% This can be changed to t = d/v where d is the distance between ptp and v
% is the velocity desired of the END EFFECTOR (may be not desireable)
time = [0 5 10 15 20 25 30 45];

% Calculate how many steps the algorithm wil calculate and declare
% memory.
amountOfSteps = (time(end)-time(1))*sr;
qOut = zeros(amountOfSteps,6); % We only save the angles.

% For all six angles, interpolate between current and next taking point
% specific constants into account. 'yes' turns on plot function, but
% for each interpolation call...
tic
for j = 1:nPts-1
    for h = 1:6
        % Run smoothstep over each pair of q.

        [qTemp, ~,~,~] = smoothstep(time(j),time(j+1),...
            q(j,h),q(j+1,h),...
            velocities(j),velocities(j+1),...
            acc,acc,sr,0);

        
        % Create range to paste output. The first range voor pts 1 to 2 starts at 1,
        % subsequent ranges start at the last value + 1.
        if j == 1
            range = 1:size(qTemp,1);  % Transpose for readability
        elseif h == 1  % For every new cycle through the q's
            range = range(end)+1:range(end)+size(qTemp,1);
        end
        
        % append to output vector
        qOut(range,h) = qTemp;
    end
    
end



% Plot q
figure
plot(time,q,'b-.')

% Interpolated q
hold on
timeVec = linspace(time(1),time(end),length(qOut));
plot(timeVec,qOut);
legend('q1','q2','q3','q4','q5','q6','q1','q2','q3','q4','q5','q6','Location','best');


% Plot points and also plot the FK points
figure
plot3(positions(:,1),positions(:,2),positions(:,3),'r-o','LineWidth',1);
hold on
plot3(FKpoints(:,1),FKpoints(:,2),FKpoints(:,3),'b-.o','LineWidth',1);


% Run FK for each set of q found.
FKpointsEase = zeros(amountOfSteps,3);
for g = 1:amountOfSteps
    FKpointsEase(g,:) = forwardKinematics(qOut(g,:));
end

% Now plot the path generated by interpolating q.
plot3(FKpointsEase(:,1),FKpointsEase(:,2),FKpointsEase(:,3),'b','LineWidth',2);
box on
shg
axis equal
camproj('perspective')
legend('Points entered into trajectory','FK points trajectory','Interpolated q','Location','Best');

%text(positions(1,:),positions(2,:),positions(3,:),[repmat('
%',nPts,1), num2str((1:nPts)')]) bugged

